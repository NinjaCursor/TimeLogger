
DROP PROCEDURE IF EXISTS LOG_EVENT #
DROP PROCEDURE IF EXISTS GET_LOG_DATA #
DROP PROCEDURE IF EXISTS GET_SUM_DATA #
DROP PROCEDURE IF EXISTS RECOVER_LOG_DATA #
DROP PROCEDURE IF EXISTS SETUP_EVENT_TABLE #

CREATE TABLE IF NOT EXISTS EVENT_LIST
(
    EVENT_NAME VARCHAR(100) NOT NULL PRIMARY KEY,
    CREATED_EPOCH BIGINT NOT NULL,
    CREATED_READABLE DATETIME NOT NULL
) #

CREATE TABLE IF NOT EXISTS LOG_TABLE
(
    ID INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    UUID VARCHAR(36) NOT NULL,
    TIME_STAMP BIGINT NOT NULL,
    EVENT_NAME VARCHAR(100) NOT NULL,
    READABLE_TIMESTAMP DATETIME NOT NULL,
    LOG_EVENT ENUM('START', 'STOP') NOT NULL
) ENGINE=MEMORY #

CREATE TABLE IF NOT EXISTS SUM_TABLE
(
    UUID VARCHAR(36) NOT NULL,
    EVENT_NAME VARCHAR(100) NOT NULL,
    TOTAL BIGINT NOT NULL,
    LAST_ACTIVE BIGINT NOT NULL,
    COUNT BIGINT NOT NULL,
    FIRST_START BIGINT NOT NULL,
    ACTIVE_NOW BOOLEAN NOT NULL,
    PRIMARY KEY (UUID, EVENT_NAME)
) ENGINE=MEMORY #

-- REGISTER_EVENT
-- @PARAMS: IN_NAME
-- @POSTCONDITION: EVENT_LIST INCLUDES IN_NAME IF IT HAD NOT ALREADY
CREATE PROCEDURE REGISTER_EVENT(IN IN_NAME VARCHAR(100))
BEGIN
    IF NOT EXISTS (SELECT 1 FROM EVENT_LIST WHERE EVENT_NAME=IN_NAME) THEN
        INSERT INTO EVENT_LIST(EVENT_NAME, CREATED_EPOCH, CREATED_READABLE) VALUES (IN_NAME, unix_timestamp(now()), NOW());
    END IF;
END; #


-- NEW_EVENT FUNCTION
-- @PARAMS: UUID, TIMESTAMP, EVENT, AND NAME OF TABLE
-- @POSTCONDITION: SUM AND LOG TABLES ARE UPDATED WITH APPROPRIATE INFORMATION BASED ON TIMESTAMP AND EVENT
CREATE PROCEDURE LOG_EVENT(IN IN_UUID VARCHAR(36), IN IN_TIME BIGINT, IN IN_EVENT ENUM('START', 'STOP', 'UPDATE'), IN IN_EVENT_NAME VARCHAR(100))
BEGIN


    SET @readable_time = from_unixtime(floor(IN_TIME)/1000);

    IF NOT EXISTS (SELECT 1 FROM EVENT_LIST WHERE EVENT_NAME=IN_EVENT_NAME) THEN
        INSERT INTO EVENT_LIST(EVENT_NAME, CREATED_EPOCH, CREATED_READABLE) VALUES (IN_EVENT_NAME, IN_TIME, @readable_time);
    END IF;

    IF IN_EVENT = 'START' THEN

        INSERT INTO SUM_TABLE(UUID, EVENT_NAME, TOTAL, LAST_ACTIVE, COUNT, FIRST_START, ACTIVE_NOW)VALUES(IN_UUID, IN_EVENT_NAME, 0, IN_TIME, 1, IN_TIME, TRUE)ON DUPLICATE KEY UPDATE LAST_ACTIVE=IN_TIME, COUNT=(COUNT+1), ACTIVE_NOW=TRUE;
        INSERT INTO LOG_TABLE(UUID, EVENT_NAME, TIME_STAMP, LOG_EVENT, READABLE_TIMESTAMP) VALUES(IN_UUID, IN_EVENT_NAME, IN_TIME, IN_EVENT, @readable_time);

    ELSEIF IN_EVENT = 'UPDATE' THEN

        UPDATE SUM_TABLE SET TOTAL=TOTAL+(IN_TIME-LAST_ACTIVE), LAST_ACTIVE=IN_TIME WHERE UUID=IN_UUID AND EVENT_NAME=IN_EVENT_NAME;

    ELSE

        UPDATE SUM_TABLE SET TOTAL=TOTAL+(IN_TIME-LAST_ACTIVE), LAST_ACTIVE=IN_TIME, ACTIVE_NOW=FALSE WHERE UUID=IN_UUID AND EVENT_NAME=IN_EVENT_NAME;
        INSERT INTO LOG_TABLE(UUID, EVENT_NAME, TIME_STAMP, LOG_EVENT, READABLE_TIMESTAMP) VALUES(IN_UUID, IN_EVENT_NAME, IN_TIME, IN_EVENT, @readable_time);

    END IF;

END; #

-- GET_LOG_DATA
-- @PARAMS: IN_UUID, EVENT_NAME
-- @POSTCONDITION: NONE
-- @RETURNS: ALL ROWS IN LOG TABLE FOR IN_UUID
CREATE PROCEDURE GET_LOG_DATA(IN IN_UUID VARCHAR(36), IN IN_EVENT_NAME VARCHAR(100))
BEGIN
    SELECT * FROM LOG_TABLE WHERE UUID=IN_UUID AND EVENT_NAME=IN_EVENT_NAME;
END; #

-- GET_SUM_DATA
-- @PARAMS: IN_UUID, EVENT_NAME
-- @POSTCONDITION: NONE
-- @RETURNS: ALL ROWS IN SUM TABLE FOR IN_UUID
CREATE PROCEDURE GET_SUM_DATA(IN IN_UUID VARCHAR(36), IN IN_EVENT_NAME VARCHAR(100))
BEGIN
    SELECT * FROM SUM_TABLE WHERE UUID=IN_UUID AND EVENT_NAME=IN_EVENT_NAME;
END; #

-- RECOVER_LOG_DATA
-- @PARAMS: EVENT_NAME
-- @PRECONDITION: ONLY RUN AT SERVER START
-- @POSTCONDITION: ANY UUID'S WITH A HANGING START VALUE WILL RECEIVE A STOP ROW AT THE TIME OF THE SUM DATA'S LAST_ACTIVE FOR THAT PERSON WHICH WILL HOPEFULLY TAKE CARE OF ISSUES WHERE THE SERVER CRASHES AND THE STOP EVENT NEVER OCCURS FOR SOME PEOPLE
CREATE PROCEDURE RECOVER_LOG_DATA()
BEGIN
    DECLARE CURRENT_UUID VARCHAR(36);
    DECLARE LAST_LOG_EVENT ENUM('START', 'STOP');

    DECLARE CURRENT_EVENT_NAME VARCHAR(100);
    DECLARE EVENT_FINISHED BOOLEAN DEFAULT 0;
    DECLARE EVENT_NAME_CURSOR CURSOR FOR SELECT EVENT_NAME FROM EVENT_LIST;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET EVENT_FINISHED = 1;

    OPEN EVENT_NAME_CURSOR;

    LOOP_EVENTS: LOOP

        FETCH EVENT_NAME_CURSOR INTO CURRENT_EVENT_NAME;

        IF EVENT_FINISHED = 1 THEN
            LEAVE LOOP_EVENTS;
        END IF;

        BLOCK2: BEGIN
            DECLARE ESTIMATED_CRASH_TIME BIGINT;
            DECLARE CURRENT_UUID VARCHAR(100);
            DECLARE UUID_FINISHED BOOLEAN DEFAULT 0;
            DECLARE UUID_CURSOR CURSOR FOR SELECT DISTINCT UUID FROM SUM_TABLE;
            DECLARE CONTINUE HANDLER FOR NOT FOUND SET UUID_FINISHED = 1;

            OPEN UUID_CURSOR;

            LOOP_UUID: LOOP

                FETCH UUID_CURSOR INTO CURRENT_UUID;

                IF UUID_FINISHED = 1 THEN
                    LEAVE LOOP_UUID;
                END IF;

                SELECT CURRENT_UUID;
                SELECT CURRENT_EVENT_NAME;

                SELECT LOG_EVENT INTO LAST_LOG_EVENT FROM LOG_TABLE WHERE UUID=CURRENT_UUID AND EVENT_NAME=CURRENT_EVENT_NAME ORDER BY ID DESC LIMIT 1;
                SELECT LAST_ACTIVE INTO ESTIMATED_CRASH_TIME FROM SUM_TABLE WHERE UUID=CURRENT_UUID AND EVENT_NAME=CURRENT_EVENT_NAME;

                -- IF LAST EVENT IS A START, SOMETHING WRONG HAPPENED, MAYBE A SERVER CRASH
                IF (LAST_LOG_EVENT = 'START') THEN
                    CALL LOG_EVENT(CURRENT_UUID, ESTIMATED_CRASH_TIME, 'STOP', CURRENT_EVENT_NAME);
                END IF;


            END LOOP LOOP_UUID;

        END;

    END LOOP LOOP_EVENTS;

END; #


-- assuming this file is loaded on startup, call recover function
CALL RECOVER_LOG_DATA(); #

